<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>report1 – артём</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../.././img/BTNBlink.webp" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../scripts.js"></script>
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">


<link rel="stylesheet" href="../../styles/custom.css">
<link rel="stylesheet" href="../../styles/scrollbar-fix.css">
</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="structural-biologys-data-format-crisis-why-pdbmmcif-cant-keep-pace-with-the-ai-era" class="level1">
<h1>Structural Biology’s Data Format Crisis: Why PDB/mmCIF Can’t Keep Pace with the AI Era</h1>
<p>The structural biology field faces an inflection point where its foundational data formats—designed for punch cards in 1972—cannot adequately represent AI-generated ensembles, petabyte-scale cryo-ET datasets, or dynamic molecular behavior. The <strong>99,999 atom limit</strong>, parser fragmentation across dozens of incompatible implementations, and inability to encode conformational heterogeneity are blocking breakthrough applications. Meanwhile, other fields have solved analogous problems: genomics achieved interoperability through HTSlib and GA4GH governance, while microscopy embraced cloud-native OME-Zarr. Structural biology must adopt similar strategies—chunked cloud formats, ensemble-centric representations, and coordinated community governance—or risk becoming an isolated island in the multi-omics landscape.</p>
<section id="the-legacy-burden-why-everyone-writes-their-own-parser" class="level2">
<h2 class="anchored" data-anchor-id="the-legacy-burden-why-everyone-writes-their-own-parser">The legacy burden: why everyone writes their own parser</h2>
<p>The PDB format’s 80-column punch-card layout imposes hard constraints that break modern workflows. The <strong>maximum 99,999 atoms</strong> (5-character field) means large cryo-EM structures display asterisks (<code>*****</code>) that crash parsers. The <strong>62-chain limit</strong> (single-character identifier) forces “split entries” where ribosomes were historically divided across multiple PDB IDs. Residue numbers cap at 9,999 per chain. These aren’t theoretical concerns—MDAnalysis GitHub issues document parsing failures when atom numbers overflow, and the BeEM converter paper notes that BioPython, cif-tools, and Atomium handle only single-character chain IDs.</p>
<p>Even mmCIF, designed to solve these limitations, creates new problems. The format contains <strong>two competing numbering systems</strong>—<code>auth_seq_id</code> (author-provided) versus <code>label_seq_id</code> (PDB-assigned)—that cause constant confusion. Chimera mailing lists document users puzzled when the same structure shows different residue numbers depending on which field the viewer reads. PyMOL defaults to auth_* fields while other tools use label_*, creating incompatible coordinate references for the same molecule.</p>
<p>Parser fragmentation is severe. The project-gemmi/mmcif-benchmark reveals dramatic performance differences: reading a 230MB file takes <strong>7.8 seconds in Gemmi but causes out-of-memory crashes in BioPython and iotbx-pdb</strong>. BioPython itself maintains two separate parsers—MMCIFParser and FastMMCIFParser—because the “correct” parser is too slow while the fast one “doesn’t aim to parse mmCIF correctly.” GitHub issues across BioPython (#775, #481, #778, #1206), MDAnalysis (#446, #2422, #3473), Gemmi (#24, #118, #178), and Boltz (#451) document parsing failures ranging from missing atom serial numbers to crashes on alternate conformations to files generated by one tool being unreadable by another.</p>
</section>
<section id="cryoet-and-alphafold-strain-every-assumption" class="level2">
<h2 class="anchored" data-anchor-id="cryoet-and-alphafold-strain-every-assumption">CryoET and AlphaFold strain every assumption</h2>
<p>The data volume explosion is staggering. <strong>EMPIAR exceeds 2 petabytes</strong> with individual datasets reaching 70+ terabytes—taking weeks to transfer even with high-bandwidth connections. The Chan Zuckerberg CryoET Data Portal contains over <strong>16,000 annotated tomograms</strong>, but annotations exist in “a wide variety of formats with varying forms and completeness of metadata,” making algorithm development and data reuse prohibitively difficult. A joint EBI/CZ Imaging Institute working group formed in April 2024 specifically to address this standardization gap.</p>
<p>AlphaFold’s <strong>214 million predicted structures</strong> introduced new data types that don’t fit existing formats. The pLDDT confidence score gets repurposed into the B-factor field—but unlike B-factors, higher pLDDT is better, causing confusion in molecular replacement workflows. The Predicted Aligned Error (PAE) matrix, critical for multi-domain interpretation, requires separate JSON files with custom parsing. Multiple sequence alignments (.a3m files) essential for reproducibility exist outside the coordinate format entirely.</p>
<p>XFEL serial crystallography generates <strong>terabytes per hour, scaling to petabytes per day</strong> at next-generation facilities. European XFEL’s 1.1 MHz repetition rate produces hundreds of thousands of diffraction patterns hourly from crystals in random unknown orientations. Multi-panel detector geometries require complex non-standardized geometry files. Real-time processing must occur during collection—current formats weren’t designed for streaming data.</p>
</section>
<section id="the-biological-context-chasm-between-structure-and-function" class="level2">
<h2 class="anchored" data-anchor-id="the-biological-context-chasm-between-structure-and-function">The biological context chasm between structure and function</h2>
<p>Structural data lacks biological meaning. A critical finding: <strong>over 60% of proteins assigned enzymatic function in SwissProt have no active site residues identified</strong> in structural databases. The Catalytic Site Atlas covers only one reference structure per curated function and isn’t regularly updated. Mapping a variant from ClinVar to its structural context requires navigating multiple databases with incompatible identifiers.</p>
<p>Biological assembly annotations are surprisingly unreliable. Estimates suggest <strong>10-15% of PDB entries contain incorrect or ambiguous biological assembly annotations</strong>. PISA algorithms often fail to correctly score heteromeric assemblies, particularly with small subunits. Crystal packing contacts get confused with biological interfaces. There’s no standardized naming convention, complicating computational analysis.</p>
<p>The wwPDB launched a major <strong>PTM remediation project (October 2024 – Spring 2025)</strong> acknowledging that post-translational modifications were historically handled inconsistently. A new <code>pdbx_modification_feature</code> category will provide instance-level PTM annotation, but this represents catching up rather than leading. Subcellular localization isn’t captured at all. Pathway context requires external database navigation. Proteoform-specific annotations are largely absent.</p>
<p>SIFTS (Structure Integration with Function, Taxonomy and Sequences) provides the crucial bridge, mapping PDB residues to UniProtKB sequences weekly. Recent advances embedded SIFTS annotations directly into mmCIF files and expanded coverage 40-fold to 1.8+ million UniProtKB sequences through UniRef90. The PDBe knowledge graph contains <strong>over 1 billion nodes and 1.5 billion edges</strong> integrating 30+ partner resources. But these remain external layers rather than intrinsic to the data format.</p>
</section>
<section id="how-genomics-and-imaging-solved-similar-problems" class="level2">
<h2 class="anchored" data-anchor-id="how-genomics-and-imaging-solved-similar-problems">How genomics and imaging solved similar problems</h2>
<p>HTSlib’s success offers a template. Downloaded over <strong>1 million times</strong> and used by 900+ GitHub projects, this reference implementation made BAM/CRAM/VCF formats practical. Key design decisions: simple human-readable text format (SAM) paired with efficient binary (BAM), strong bundled reference implementation, indexability for random region access, extensibility via optional tags, and MIT/BSD licensing enabling commercial adoption. The format evolved—CRAM achieved 40-60% smaller files through reference-based compression while maintaining backward compatibility.</p>
<p>The GA4GH governance model provides organizational structure. Eight Work Streams and 24 Driver Projects engage <strong>over 1,000 individuals from 90+ countries and 650+ organizations</strong>. Standards emerge from real implementer needs through Study Groups, get formalized in Work Streams, and pilot through the Global Implementers Forum. This creates buy-in and ensures practical utility.</p>
<p>OME-Zarr demonstrates cloud-native design done right. Built for object storage from inception, it uses <strong>chunked N-dimensional arrays</strong> where each chunk is an independent file. Multi-resolution pyramids are built in. Hierarchical JSON metadata sits at each level. Implementations exist in Python, Java, JavaScript, C++, Rust, and Julia. The sharding innovation in Zarr v3 groups multiple chunks per object to handle filesystem limits while maintaining parallelism. Latency advantages are fundamental: monolithic formats require multiple round-trips while Zarr chunks are independent.</p>
<p>The critical lesson: <strong>reference implementation quality determines adoption</strong>. Formats without good libraries don’t get used regardless of theoretical elegance. Community governance through neutral international consortia builds trust. Cloud-native chunked formats are essential for object storage. Extensibility via optional fields enables evolution without breaking existing tools.</p>
</section>
<section id="what-would-transform-the-field-ensemble-native-ai-ready-infrastructure" class="level2">
<h2 class="anchored" data-anchor-id="what-would-transform-the-field-ensemble-native-ai-ready-infrastructure">What would transform the field: ensemble-native, AI-ready infrastructure</h2>
<p>A 2024 paper in Acta Crystallographica D states the core problem directly: “Although new tools are available to detect conformational and compositional heterogeneity within these ensembles, <strong>the legacy PDB data structure does not robustly encapsulate this complexity.</strong>” Current formats encode single conformational states despite biomolecules existing in dynamic ensembles. Intrinsically disordered proteins populate conformational ranges best described by heterogeneous ensembles—features “notoriously difficult to characterize” because they’re “lost by ensemble methods of structural characterization.”</p>
<p><strong>AI-native format requirements</strong> are now well-understood: - <strong>E(3)/SE(3) equivariance preservation</strong> under geometric transformations - <strong>Native graph representations</strong> with k-nearest neighbor graphs, edge type annotations, and node features for GNNs like GearNet and DeepRank-GNN - <strong>Multi-resolution tokenization</strong> (AlphaFold 3 uses flexible schemes: standard residues as single tokens, modified residues as atoms, ligands as individual atoms) - <strong>Pre-computed MSA embeddings</strong> as feature channels - <strong>Confidence metrics</strong> (pLDDT, PAE) as first-class data alongside coordinates - <strong>Versioned model parameters</strong> linking predictions to the networks that generated them</p>
<p>Real-time streaming for time-resolved experiments requires time-indexed 4D coordinate trajectories, native support for incomplete/sparse datasets, and streaming formats compatible with Apache Kafka/Spark. BioCARS achieves time resolutions from 100 picoseconds to seconds; mix-and-inject serial crystallography captures enzyme catalysis with 2-7 millisecond temporal resolution. These generate data requiring storage paradigms beyond static files.</p>
<p>Ensemble representation extensions should include conformer population weights as first-class metadata, state transition matrices linking related conformations, per-coordinate uncertainty quantification, and links between experimental observables and ensemble statistics. The Protein Ensemble Database (PED) demonstrates what structured IDP ensemble metadata looks like—conformer counts, modeling resolution levels, validation status—but this remains isolated from mainstream structural formats.</p>
</section>
<section id="the-multi-omics-integration-imperative" class="level2">
<h2 class="anchored" data-anchor-id="the-multi-omics-integration-imperative">The multi-omics integration imperative</h2>
<p>The disconnect is stark: each omics type has distinct data structures, distributions, and batch effects. There are no standardized preprocessing protocols across omics layers. Programs require non-standard inputs and output incompatible formats, forcing researchers to write conversion scripts for every integration.</p>
<p>Tools like GLUE use graph variational autoencoders to anchor features using prior biological knowledge. MOFA+ and iCluster map multi-omics onto shared representations. But structural data sits outside these frameworks. A complete structural-omics pipeline—raw cryo-EM through single-particle analysis, subunit fitting, mass spectrometry validation, multi-omics annotation, integrative modeling via IMP or HADDOCK, to validated assembly—currently requires crossing multiple format boundaries with manual intervention at each step.</p>
<p>The PDBe knowledge graph represents the most ambitious current integration, but accessing biological context still requires navigating multiple APIs and external resources. For structural data to participate in systems biology, <strong>format-level integration points</strong> must exist: knowledge graphs linking structural data to genomic variants (AlphaMissense), protein modifications, interaction networks, and pathway annotations as native data channels rather than external lookups.</p>
</section>
<section id="toward-next-generation-structural-data-infrastructure" class="level2">
<h2 class="anchored" data-anchor-id="toward-next-generation-structural-data-infrastructure">Toward next-generation structural data infrastructure</h2>
<p><strong>Near-term priorities (1-5 years)</strong> should include mandatory PDBx/mmCIF adoption before four-character PDB IDs exhaust around 2028, standardized cryo-EM interchange eliminating the cryoSPARC/RELION conversion mess, ensemble mmCIF extensions implementing proposed conformational heterogeneity categories, and GraphML/JSON-Graph exports providing ML-ready graph representations from coordinate files.</p>
<p><strong>Medium-term developments (5-15 years)</strong> require streaming data standards with time-indexed 4D structural formats, multi-omics structural schemas linking to genomic/proteomic annotations, federated structural databases enabling distributed queries across PDB/EMDB/BMRB/PED, and AI model versioning tracking which networks produced which predictions.</p>
<p>Cloud infrastructure exists but needs structural biology adaptation. SBGrid’s SBCloud provides Slurm-based clusters with 620+ curated structural biology applications through Open OnDemand browser interfaces. Provenance tracking exists in specialized systems like PDB-REDO Cloud with detailed records documenting input versioning and program versions. The technical foundations are present—PDBx/mmCIF extensibility, cloud infrastructure, graph neural network frameworks, FAIR principles. The challenge is coordinated community adoption.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The wwPDB PDBx/mmCIF Working Group faces a forcing function: the 2028 extended PDB ID transition will require universal format migration regardless. This creates an opportunity to implement ensemble representation extensions, AI-native features, and cloud-optimized chunked storage simultaneously rather than incrementally. The alternative—continuing with formats designed for punch cards while the rest of biology moves to cloud-native, AI-ready infrastructure—risks structural biology becoming isolated from the integrated multi-omics future. Other fields have demonstrated the path: strong reference implementations, neutral governance bodies, extensible formats, and cloud-native architecture. The question is whether structural biology will follow before the format limitations become the binding constraint on discovery.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/rtviii\.xyz");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>