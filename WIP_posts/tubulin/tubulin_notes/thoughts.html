<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>thoughts – артём</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../.././img/BTNBlink.webp" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../../scripts.js"></script>
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">


<link rel="stylesheet" href="../../../styles/custom.css">
<link rel="stylesheet" href="../../../styles/scrollbar-fix.css">
</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">




<p>Tubulin Database Application Design From the perspective of the tubulin research community, here are the key elements your database application should incorporate: Structural Classifications</p>
<p>Isotype tracking: Alpha/beta/gamma tubulin variants with their distinct structural features PTM mapping: Comprehensive post-translational modification sites (acetylation, tyrosination, polyglutamylation, etc.) Conformational states: Straight vs.&nbsp;curved, GTP vs.&nbsp;GDP-bound states Lattice arrangements: A vs.&nbsp;B lattice, protofilament number variations (13 vs.&nbsp;non-13) Interface classifications: Lateral and longitudinal contact regions Seam structures: Variations in microtubule seam architecture</p>
<p>Biologically Relevant Operations</p>
<p>PTM pattern search: Query by specific modification patterns Structural alignment tools: Compare conformational changes between states Pharmacological binding site analysis: Drug interaction surfaces MAP binding region identification: Sites for motor proteins and other MAPs Evolutionary conservation mapping: Highlight conserved regions across species Disease-associated mutation correlation: Link mutations to structural changes</p>
<p>Critical Loci</p>
<p>Nucleotide binding pockets: GTP/GDP binding sites ## drug-binding domains ## Exchangeable vs.&nbsp;non-exchangeable nucleotide sites ## Highly variable regions subject to most PTMs ## Critical for polymerization dynamics Loop regions: T5, H1-S2, M, etc. that change conformation during dynamics</p>
<p>Additional Functionalities</p>
<p>Filtering: Feature-navigable structural data Experimental method classification: Cryo-EM vs.&nbsp;X-ray crystallography sources Taxonomic organization: Species-specific tubulin structures Integrated visualization: Direct linking to molecular viewers with highlighting options</p>
<p>Would you like me to expand on any particular aspect of this database design?</p>
<section id="ptms" class="level1">
<h1>PTMS</h1>
<section id="acetylation" class="level4">
<h4 class="anchored" data-anchor-id="acetylation">Acetylation</h4>
<p>Chemistry: Addition of an acetyl group (-COCH₃) Location: Primarily occurs on lysine-40 of α-tubulin in the microtubule lumen Persistence: Marks stable, long-lived microtubules Function: Increases microtubule mechanical resilience, affects kinesin binding Structures: PDB entries like 5JCO and 6U42 show acetylated tubulin</p>
</section>
<section id="detyrosinationtyrosination" class="level4">
<h4 class="anchored" data-anchor-id="detyrosinationtyrosination">Detyrosination/Tyrosination</h4>
<p>Chemistry: Removal of C-terminal tyrosine from α-tubulin (detyrosination), followed by possible re-addition (tyrosination) Location: Extreme C-terminal tail of α-tubulin Persistence: Detyrosination accumulates on stable microtubules Function: Regulates interactions with +TIPs, CAP-Gly proteins, and some motors Structures: Mostly studied through biochemical methods as CTTs are often disordered in crystal structures</p>
</section>
<section id="glutamylation" class="level4">
<h4 class="anchored" data-anchor-id="glutamylation">Glutamylation</h4>
<p>Chemistry: Addition of glutamate side chains (1-6+ units) Location: Glutamate residues in both α- and β-tubulin CTTs Persistence: Variable, can be dynamically regulated Function: Regulates motor trafficking, severing enzyme activity (spastin, katanin) Structures: Challenging to visualize in structural studies due to CTT flexibility</p>
</section>
<section id="glycylation" class="level4">
<h4 class="anchored" data-anchor-id="glycylation">Glycylation</h4>
<p>Chemistry: Addition of glycine residues (1-34+ units) Location: Similar sites as glutamylation on CTTs Persistence: Predominant in stable ciliary and flagellar microtubules Function: Critical for ciliary and flagellar stability Structures: Limited structural data due to CTT flexibility</p>
</section>
<section id="phosphorylation" class="level4">
<h4 class="anchored" data-anchor-id="phosphorylation">Phosphorylation</h4>
<p>Chemistry: Addition of phosphate group to serine, threonine, or tyrosine Location: Various sites including Ser172 on β-tubulin Persistence: Dynamic, often cell-cycle regulated Function: Can inhibit microtubule assembly, regulates dynamics Structures: Some phosphorylated sites visible in structures like 3EDL</p>
</section>
<section id="methylation" class="level4">
<h4 class="anchored" data-anchor-id="methylation">Methylation</h4>
<p>Chemistry: Addition of methyl groups to lysine or arginine residues Location: Various sites in the globular domain Persistence: Less characterized than other PTMs Function: May affect protein-protein interactions Structures: Limited structural information</p>
</section>
<section id="palmitoylation" class="level4">
<h4 class="anchored" data-anchor-id="palmitoylation">Palmitoylation</h4>
<p>Chemistry: Attachment of palmitic acid via thioester bond to cysteine Location: Cysteine residues, particularly Cys376 in α-tubulin Persistence: Reversible lipid modification Function: May affect membrane association Structures: Difficult to capture in crystal structures</p>
</section>
<section id="succinylationmalonylation" class="level4">
<h4 class="anchored" data-anchor-id="succinylationmalonylation">Succinylation/Malonylation</h4>
<p>Chemistry: Addition of succinyl or malonyl groups to lysine residues Location: Various lysine residues throughout tubulin Persistence: Newly characterized, less understood Function: May affect protein stability and interactions Structures: Limited structural data</p>
</section>
<section id="citrullination" class="level4">
<h4 class="anchored" data-anchor-id="citrullination">Citrullination</h4>
<p>Chemistry: Conversion of arginine to citrulline Location: Arginine residues throughout tubulin Persistence: Generally stable modification Function: May affect microtubule stability Structures: Limited structural information</p>
</section>
<section id="marylation-mono-adp-ribosylation" class="level4">
<h4 class="anchored" data-anchor-id="marylation-mono-adp-ribosylation">MARylation (Mono-ADP-ribosylation)</h4>
<p>Chemistry: Addition of ADP-ribose from NAD⁺ Location: Various residues including glutamate and arginine Persistence: Reversible, can be rapidly regulated Function: Often stress-responsive, can affect protein interactions Structures: Few structures available</p>
<p>Viewing These PTMs Most high-resolution structures of tubulin (like 1TUB, 6EVW, 5SYF) don’t include the complete CTTs where many PTMs occur, as these regions are intrinsically disordered. However, you can find structures capturing some PTMs:</p>
<p>For acetylated tubulin, check PDB entries like 5JCO For phosphorylated sites, structures like 3EDL show some sites The Protein Data Bank (PDB) contains numerous tubulin structures, but only a fraction capture PTMs</p>
<p>For many of these PTMs, structural visualization is challenging because:</p>
<p>The CTTs are highly flexible Many PTMs are transient Sample preparation for crystallography often removes these modifications</p>
<p>Researchers often use molecular dynamics simulations to model how these PTMs might affect tubulin structure and interactions when direct structural data is unavailable.</p>
</section>
</section>
<section id="databases" class="level1">
<h1>Databases</h1>
<p>https://proteininformationresource.org/resid/ PhosphoSitePlus Tubulin Database</p>
<p>#TODO: What formats do PTM databases and <strong>mass spec</strong> use?</p>
<hr>
</section>
<section id="isotypes" class="level1">
<h1>Isotypes</h1>
<p>You’ve hit on an important point about the relationship between structural biology and the broader knowledge of tubulin biology. Your instinct is correct - this approach is actually becoming more realistic and is happening in advanced tubulin research.</p>
<p>What you’re describing is essentially a form of “computational reconstruction” or “biologically-informed modeling” that combines:</p>
<pre><code>The structural scaffold from cryo-EM
Biochemical/proteomic knowledge of isotype composition
Prior knowledge about isotype-specific sequence differences</code></pre>
<p>This approach is indeed being used by specialized tubulin researchers. Here’s how it works in practice:</p>
<pre><code>Mass spectrometry or other techniques determine the precise isotype composition of a particular cellular structure (e.g., "this cilium contains 60% TUBA1A, 25% TUBA4A, 10% TUBA8, 5% TUBA3C")
The cryo-EM structure provides the overall architecture and placement of subunits
Researchers can then create computational models that distribute these isotypes according to:
    Known preferences for certain positions in the lattice
    Known partner preferences (some α-isotypes preferentially pair with specific β-isotypes)
    Experimentally determined ratios</code></pre>
<p>This isn’t routine yet, but specialized labs focusing on tubulin biology do perform this kind of reconstruction for specific questions. It’s particularly relevant when studying:</p>
<pre><code>How drugs interact differently with specific isotypes
How certain mutations in specific isotypes cause disease
How post-translational modifications interact with isotype-specific sequences</code></pre>
<p>The challenge remains that we can’t definitively say “this specific subunit at position X in this specific microtubule is isotype Y” from the cryo-EM data alone. But the kind of informed reconstruction you’re describing represents the cutting edge of integrating structural and biochemical data in tubulin research.</p>
<section id="how-different-isotypes-are-resolved-structurally" class="level3">
<h3 class="anchored" data-anchor-id="how-different-isotypes-are-resolved-structurally">How different isotypes are resolved structurally</h3>
<ul>
<li><p>Typically, the starting scaffold is one of:</p>
<p>Consensus sequence: A synthetic sequence representing the most common residue at each position across all relevant isotypes.</p>
<p>Dominant isotype: The most abundant isotype in the sample (e.g., TUBA1A for brain microtubules) serves as the template.</p>
<p>Reference structure: Sometimes a well-resolved X-ray structure (often from bovine or porcine tubulin) is used, even if it’s not identical to the isotypes being studied.</p></li>
<li><p>Reconstruction/Modeling Approaches</p></li>
</ul>
<p>The transformation from scaffold to isotype-specific models typically involves:</p>
<pre><code>Homology modeling: Using tools like MODELLER, Rosetta, or AlphaFold to generate structural predictions for specific isotypes based on the template.
Flexible fitting: The homology models are then fitted into the cryo-EM density with tools like MDFF (Molecular Dynamics Flexible Fitting), Flex-EM, or Phenix real-space refinement.
Energy minimization: MD simulations help resolve steric clashes and optimize the structure.</code></pre>
<p>The key difference from standard homology modeling is that the cryo-EM density serves as an additional constraint - the model must both satisfy physics-based energy terms and fit the experimental density. Handling Structural Differences</p>
<p>You’re absolutely right that sequence differences can engender structural changes. This is handled in a few ways:</p>
<pre><code>Local refinement: Areas with sequence differences get more extensive sampling and refinement.
Ensemble modeling: Sometimes multiple conformations are modeled for regions with significant differences.
Validation: Using MD simulations to test if the modified structure remains stable.</code></pre>
<p>A/B interfaces ?</p>
<p>so, it appears that ptms are somewhat inaccisible within a lot of cryoem strcutrues due to resolution. at least for now and at least not fully and cosistently (though some papers do resolve PTMs like acetylated K40: https://www.cell.com/action/showPdf?pii=S0092-8674%2819%2931081-5). How can we “repair” these structures to be able to display and have faithful structural references(at least up to the veracity of the upstream data ex. seq and PTM). Can we “inject” PTMs dynamically into a template structure and then post-repair the strucutre locally with, say, rosetta?</p>
<hr>
</section>
<section id="ptms-1" class="level3">
<h3 class="anchored" data-anchor-id="ptms-1">PTMs</h3>
<ol type="1">
<li><p>Structure tools that could enable ptms recovery/exploration in atomic structures.</p></li>
<li><p>Sort vis-a-vis the applications (downstream MD? MAP binding? Dynamics? how is this all done?)</p></li>
</ol>
<hr>
<p>what volumes and diversities are avaiable routinely via Mass Spec and other methods in terms of seqeunces and resolution</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/rtviii\.xyz");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>