<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Artem Kushner">
<meta name="dcterms.date" content="2026-02-17">

<title>CryoET Concepts in Pixels, Boxes, and FFTs – артём</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../.././img/BTNBlink.webp" rel="icon">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="../../scripts.js"></script>
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles/custom.css">
<link rel="stylesheet" href="../../styles/scrollbar-fix.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#pixels-frequencies-what-spectrum-means" id="toc-pixels-frequencies-what-spectrum-means" class="nav-link active" data-scroll-target="#pixels-frequencies-what-spectrum-means"><span class="header-section-number">1</span> 1. Pixels → Frequencies: what “spectrum” means</a>
  <ul class="collapse">
  <li><a href="#power-spectrum" id="toc-power-spectrum" class="nav-link" data-scroll-target="#power-spectrum"><span class="header-section-number">1.1</span> Power spectrum</a></li>
  </ul></li>
  <li><a href="#åpx-nyquist-and-high-frequencies" id="toc-åpx-nyquist-and-high-frequencies" class="nav-link" data-scroll-target="#åpx-nyquist-and-high-frequencies"><span class="header-section-number">2</span> 2. Å/px, Nyquist, and “High Frequencies”</a>
  <ul class="collapse">
  <li><a href="#åpx-apix" id="toc-åpx-apix" class="nav-link" data-scroll-target="#åpx-apix"><span class="header-section-number">2.1</span> Å/px (apix)</a></li>
  <li><a href="#nyquist-in-pixels" id="toc-nyquist-in-pixels" class="nav-link" data-scroll-target="#nyquist-in-pixels"><span class="header-section-number">2.2</span> Nyquist (in pixels)</a></li>
  <li><a href="#high-frequency-in-this-context" id="toc-high-frequency-in-this-context" class="nav-link" data-scroll-target="#high-frequency-in-this-context"><span class="header-section-number">2.3</span> “High frequency” in this context</a></li>
  </ul></li>
  <li><a href="#ctf-oscillations-and-phase-flips" id="toc-ctf-oscillations-and-phase-flips" class="nav-link" data-scroll-target="#ctf-oscillations-and-phase-flips"><span class="header-section-number">3</span> 3. CTF: Oscillations and Phase Flips</a>
  <ul class="collapse">
  <li><a href="#the-key-ctf-changes-sign-as-a-function-of-frequency" id="toc-the-key-ctf-changes-sign-as-a-function-of-frequency" class="nav-link" data-scroll-target="#the-key-ctf-changes-sign-as-a-function-of-frequency"><span class="header-section-number">3.1</span> The key: CTF changes sign as a function of frequency</a></li>
  </ul></li>
  <li><a href="#ctf-correction" id="toc-ctf-correction" class="nav-link" data-scroll-target="#ctf-correction"><span class="header-section-number">4</span> 4. CTF Correction</a>
  <ul class="collapse">
  <li><a href="#phase-flipping-simplest" id="toc-phase-flipping-simplest" class="nav-link" data-scroll-target="#phase-flipping-simplest"><span class="header-section-number">4.1</span> Phase-flipping (simplest)</a></li>
  <li><a href="#full-correction-wiener-filter" id="toc-full-correction-wiener-filter" class="nav-link" data-scroll-target="#full-correction-wiener-filter"><span class="header-section-number">4.2</span> Full correction (Wiener Filter)</a></li>
  </ul></li>
  <li><a href="#deconvolution" id="toc-deconvolution" class="nav-link" data-scroll-target="#deconvolution"><span class="header-section-number">5</span> 5. Deconvolution</a></li>
  <li><a href="#normalization-and-box-size" id="toc-normalization-and-box-size" class="nav-link" data-scroll-target="#normalization-and-box-size"><span class="header-section-number">6</span> 6. Normalization and Box Size</a></li>
  <li><a href="#filtering-the-40-å-low-pass" id="toc-filtering-the-40-å-low-pass" class="nav-link" data-scroll-target="#filtering-the-40-å-low-pass"><span class="header-section-number">7</span> 7. Filtering: The “40 Å Low-pass”</a></li>
  <li><a href="#why-whitening-is-called-whitening" id="toc-why-whitening-is-called-whitening" class="nav-link" data-scroll-target="#why-whitening-is-called-whitening"><span class="header-section-number">8</span> 8. Why “Whitening” is called Whitening</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">CryoET Concepts in Pixels, Boxes, and FFTs</h1>
<p class="subtitle lead">A No-Jargon Guide to Frequency Space and Reconstruction</p>
  <div class="quarto-categories">
    <div class="quarto-category">cryo-ET</div>
    <div class="quarto-category">structural biology</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Artem Kushner </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 17, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Cool — let’s throw away the jargon and build it from <strong>pixels in a box</strong>, with just enough math to make the knobs feel inevitable.</p>
<p>I’m going to do it in this order:</p>
<ol type="1">
<li><strong>What “frequency” means for an image/volume</strong> (pixels → FFT → spectrum)</li>
<li><strong>Å/px + Nyquist + “high frequencies”</strong> (what’s actually high)</li>
<li><strong>CTF</strong>: what “oscillations” and “phase flips” literally mean</li>
<li><strong>CTF “correction”</strong>: what operations people actually do</li>
<li><strong>Deconvolution</strong>: what it implies in this context</li>
<li><strong>Normalization + box size</strong> (for template matching)</li>
<li><strong>Power spectrum, low-pass 40 Å, and what Å means in frequency space</strong></li>
<li><strong>Why “whitening” is called whitening</strong></li>
</ol>
<section id="pixels-frequencies-what-spectrum-means" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="pixels-frequencies-what-spectrum-means"><span class="header-section-number">1</span> 1. Pixels → Frequencies: what “spectrum” means</h2>
<p>Take the simplest case: a <strong>1D</strong> signal: an array of numbers</p>
<p><span class="math display">\[
x[n],\quad n=0,\dots,N-1
\]</span></p>
<p>A “frequency component” is “how much of a sine/cosine wave at a given wavelength is present”. The FFT gives you:</p>
<p><span class="math display">\[
X[k] = \sum_{n=0}^{N-1} x[n]\; e^{-i 2\pi kn/N}
\]</span></p>
<ul>
<li><span class="math inline">\(X[k]\)</span> is <strong>complex</strong>: it has magnitude and phase.</li>
<li>Each <span class="math inline">\(k\)</span> corresponds to a spatial frequency (cycles per length).</li>
</ul>
<p>Now upgrade to a <strong>2D image</strong> <span class="math inline">\(x[y,x]\)</span>: FFT gives <span class="math inline">\(X[k_y,k_x]\)</span>.<br>
Upgrade to a <strong>3D volume</strong> <span class="math inline">\(x[z,y,x]\)</span>: FFT gives <span class="math inline">\(X[k_z,k_y,k_x]\)</span>.</p>
<p>So “the spectrum” in cryoET is just:<br>
&gt; <strong>the FFT of your 3D voxel box, indexed by spatial frequencies in 3D.</strong></p>
<section id="power-spectrum" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="power-spectrum"><span class="header-section-number">1.1</span> Power spectrum</h3>
<p>The <strong>power</strong> at a frequency is:</p>
<p><span class="math display">\[
P(\mathbf{k}) = |X(\mathbf{k})|^2
\]</span></p>
<p>Often people radially average it into a 1D curve vs radius <span class="math inline">\(|\mathbf{k}|\)</span>. That curve is what they call “the power spectrum”.</p>
</section>
</section>
<section id="åpx-nyquist-and-high-frequencies" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="åpx-nyquist-and-high-frequencies"><span class="header-section-number">2</span> 2. Å/px, Nyquist, and “High Frequencies”</h2>
<section id="åpx-apix" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="åpx-apix"><span class="header-section-number">2.1</span> Å/px (apix)</h3>
<p>Your volume is a grid. Each voxel corresponds to a physical spacing:</p>
<ul>
<li>voxel size = <span class="math inline">\(a\)</span> Å/px</li>
</ul>
<p>So if <span class="math inline">\(a=12\)</span> Å/px, then one voxel step is 12 Å in the sample.</p>
</section>
<section id="nyquist-in-pixels" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="nyquist-in-pixels"><span class="header-section-number">2.2</span> Nyquist (in pixels)</h3>
<p>On a discrete grid, the shortest wavelength you can represent is <strong>2 pixels</strong> (one up-down cycle). That’s the sampling theorem. So the best possible (sampling-limited) real-space resolution is:</p>
<p><span class="math display">\[
\text{Nyquist resolution} = 2a\ \text{Å}
\]</span></p>
<p>Example: <span class="math inline">\(a=12\)</span> Å/px → Nyquist = 24 Å.<br>
Meaning: you literally cannot represent features smaller than ~24 Å reliably in that sampled volume, because you don’t have enough samples.</p>
</section>
<section id="high-frequency-in-this-context" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="high-frequency-in-this-context"><span class="header-section-number">2.3</span> “High frequency” in this context</h3>
<p>“Frequency” here means <strong>spatial frequency</strong>:</p>
<ul>
<li><strong>low spatial frequency</strong> = slowly varying stuff (big blobs, gradients)</li>
<li><strong>high spatial frequency</strong> = rapid changes (edges, fine detail)</li>
</ul>
<p>If a feature has size <span class="math inline">\(d\)</span> Å, then its spatial frequency is about:</p>
<p><span class="math display">\[
f \approx 1/d\quad (\text{units: } \text{Å}^{-1})
\]</span></p>
<p>So “high frequencies” are the ones with <strong>small d</strong> (fine details), approaching Nyquist.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why is apix often &gt; 1?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Careful: <strong>apix is a sampling choice</strong>, not the microscope’s fundamental limit. In cryoET, people often reconstruct at binned pixel sizes like 4–15 Å/px because tomograms are noisy, the missing wedge exists, and computational cost explodes at small pixels.</p>
</div>
</div>
</section>
</section>
<section id="ctf-oscillations-and-phase-flips" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="ctf-oscillations-and-phase-flips"><span class="header-section-number">3</span> 3. CTF: Oscillations and Phase Flips</h2>
<p>Think of your sample as producing some “ideal” projection signal in Fourier space <span class="math inline">\(S(\mathbf{k})\)</span>. The microscope multiplies it by a frequency-dependent function:</p>
<p><span class="math display">\[
I(\mathbf{k}) \approx \text{CTF}(\mathbf{k}) \cdot S(\mathbf{k}) + N(\mathbf{k})
\]</span></p>
<section id="the-key-ctf-changes-sign-as-a-function-of-frequency" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="the-key-ctf-changes-sign-as-a-function-of-frequency"><span class="header-section-number">3.1</span> The key: CTF changes sign as a function of frequency</h3>
<p>A simplified form is:</p>
<p><span class="math display">\[
\text{CTF}(k) = \sin(\chi(k))
\]</span></p>
<p>where <span class="math inline">\(\chi(k)\)</span> depends on defocus, wavelength, etc. The important qualitative fact: <span class="math inline">\(\sin(\chi)\)</span> oscillates: +, 0, −, 0, +, 0, − … as <span class="math inline">\(k\)</span> increases.</p>
<ul>
<li><strong>Positive sign</strong>: signal is transmitted normally.</li>
<li><strong>Negative sign</strong>: signal is <strong>inverted</strong> (multiplying by -1). This is the <strong>“phase flip”</strong>.</li>
<li><strong>Zeros</strong>: the frequency is basically wiped out.</li>
</ul>
</section>
</section>
<section id="ctf-correction" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="ctf-correction"><span class="header-section-number">4</span> 4. CTF Correction</h2>
<p>Correction tries to undo that multiplication.</p>
<section id="phase-flipping-simplest" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="phase-flipping-simplest"><span class="header-section-number">4.1</span> Phase-flipping (simplest)</h3>
<p>If you only fix the sign:</p>
<p><span class="math display">\[
S'(\mathbf{k}) = \text{sign}(\text{CTF}(\mathbf{k}))\cdot I(\mathbf{k})
\]</span></p>
</section>
<section id="full-correction-wiener-filter" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="full-correction-wiener-filter"><span class="header-section-number">4.2</span> Full correction (Wiener Filter)</h3>
<p>Naively dividing by CTF explodes noise where the CTF is near 0. Instead, we use:</p>
<p><span class="math display">\[
S'(\mathbf{k}) = \frac{\text{CTF}(\mathbf{k})}{\text{CTF}(\mathbf{k})^2 + \alpha}\; I(\mathbf{k})
\]</span></p>
<ul>
<li><span class="math inline">\(\alpha\)</span> is a “noise / signal” regularization parameter.</li>
</ul>
</section>
</section>
<section id="deconvolution" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="deconvolution"><span class="header-section-number">5</span> 5. Deconvolution</h2>
<p>In cryoET pipelines, <strong>“deconv”</strong> is usually shorthand for undoing CTF envelope damping or reconstruction blur. It behaves like a <strong>sharpening filter</strong>: it boosts higher frequencies relative to low frequencies, increasing edge contrast.</p>
</section>
<section id="normalization-and-box-size" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="normalization-and-box-size"><span class="header-section-number">6</span> 6. Normalization and Box Size</h2>
<p>Template matching uses <strong>normalized cross-correlation</strong> (NCC):</p>
<p><span class="math display">\[
\text{NCC}(v,t)= \frac{\sum_i (v_i - \mu_v)(t_i-\mu_t)} {\sqrt{\sum_i (v_i-\mu_v)^2}\;\sqrt{\sum_i (t_i-\mu_t)^2}}
\]</span></p>
<p>Normalization ensures that the match score depends on <strong>shape similarity</strong>, not on absolute intensity or local contrast.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Box size constraints
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><strong>Too small</strong>: stats dominated by the particle itself; you normalize away the signal.</li>
<li><strong>Too big</strong>: stats dominated by background gradients/lamella thickness; normalization becomes unstable.</li>
</ul>
</div>
</div>
</section>
<section id="filtering-the-40-å-low-pass" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="filtering-the-40-å-low-pass"><span class="header-section-number">7</span> 7. Filtering: The “40 Å Low-pass”</h2>
<p>A low-pass filter at 40 Å is a cutoff in frequency space. Convert the length scale to a spatial frequency:</p>
<p><span class="math display">\[
f_c = 1/40\ \text{Å}^{-1} = 0.025\ \text{Å}^{-1}
\]</span></p>
<p>You multiply your FFT by a filter function <span class="math inline">\(W(\mathbf{k})\)</span> that suppresses anything higher than <span class="math inline">\(f_c\)</span> and then inverse FFT back:</p>
<p><span class="math display">\[
x_\text{filtered} = \mathcal{F}^{-1}\{ W(\mathbf{k}) X(\mathbf{k}) \}
\]</span></p>
</section>
<section id="why-whitening-is-called-whitening" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="why-whitening-is-called-whitening"><span class="header-section-number">8</span> 8. Why “Whitening” is called Whitening</h2>
<p><strong>White noise</strong> has equal power at all frequencies (a flat spectrum). If your data is “colored” (certain frequencies dominate), you “whiten” it by scaling:</p>
<p><span class="math display">\[
X_\text{white}(\mathbf{k}) = \frac{X(\mathbf{k})}{\sqrt{P(|\mathbf{k}|)}}
\]</span></p>
<p>This is <strong>frequency-dependent scaling</strong>, not averaging. It ensures no specific frequency band unfairly dominates the match score.</p>
<hr>
<p><strong>Next step:</strong> Since we’ve cleared up the theory, would you like me to look at those specific score maps from your logs to see exactly how toggling “whitening” changed your standard deviation and false-positive cutoffs?</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/rtviii\.xyz");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>